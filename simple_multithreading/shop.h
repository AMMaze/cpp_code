#pragma once 

#include <string>
#include <list>
#include <memory>
#include "product.h"
#include <utility>
#include <tuple>
#include <map>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <atomic>

class IProduct;

enum ProdEvents {
    PRICE_CHANGE,
    SALES_CHANGE,
    STOP_SALES,
    PLACEHOLDER
};


using SProd = std::shared_ptr<IProduct>;

class IShop {
    //attached products
    std::map<const std::string, IProduct*> products;

    //products that are on sale
    std::map<const std::string, double> active_prods;

#ifdef USE_QUEUE   
    //event queue
    static std::list<std::tuple<const std::string, ProdEvents, int>> events;
    //separate event queue for stops since the actual object can be 
    //deleted before observers would process all events related to it 
    //in the events queue
    static std::list<std::tuple<const std::string, ProdEvents, int>> stop;
    
    //iterators for observers to preserve last position in queue
    std::list<std::tuple<const std::string, ProdEvents, int>>::iterator pos;
    std::list<std::tuple<const std::string, ProdEvents, int>>::iterator spos;
#else
    //synchronous alternative to event queue:
    //--only one event can be generated at a time
    //--it will last until processed by every existing observer
    static std::tuple<std::string, ProdEvents, int> cur_event;
    static int event_id;

    int last_event_id;
#endif
    static void AddEvent(const std::string& name, ProdEvents event);
    static void AddStop(const std::string& name);

    void AddProduct(IProduct* prod);
    void RemoveProduct(IProduct* prod);

    static std::mutex qlck;
    static std::mutex out;
    static std::mutex destruct_lck;

    void ProcessEvents();
    void ProcessStops();

    //counts created objects
    //needed to know how many observers should process issued event
    static int shops_cnt;
    
    std::string name;

    friend class IProduct;

    void Observe();
    static std::condition_variable qwait; 
    std::atomic<bool> join_observer;
    std::mutex local_lists;
    std::thread obsrv;
    void Reset();

public:
    void ListItems();
    
    //when constructed, spawns thread that executes Observe function
    //it's purpose is to watch and process events generated by products
    //observer joined in destructor
    virtual ~IShop();
    IShop(const std::string& n);


};
